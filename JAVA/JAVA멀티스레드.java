멀티스레드 : 하나의 프로세스에서 두가지 이상의 작업을 동시에 처리하는 것. / 하나의 스레드 문제 발생 -> 전체 스레드에 영향을 미침.
ex) 게임, 클라이언트-서버
스레드 : 코드의 실행 흐름.
---------------------------------------------------------------------------------------------
모든 자바 프로그램은 메인스레드가 main()메소드를 실행하면서 시작. -> main()메소드의 마지막코드 or return 만나면 실행 종료.
자바는 작업 스레드를 객체로 관리 - Thread 객체명 = Thread.currentThread(); System.out.println(currThread.getName());
"멀티스레드에서는 실행중인 스레드가 존재 시 프로세스 종료 X."
---------------------------------------------------------------------------------------------
작업 스레드 생성 방법
1. Thread클래스로 작업 스레드 객체 직접 생성 - Thread 스레드객체명 = new Thread(Runnable 객체명); //Runnable upcasting //Runnable = 스레드가 처리해야할 작업내용을 가진 객체
2. Thread의 자식클래스를 정의하여 작업 스레드 생성 in 익명객체 - Thread 스객명 = new Thread() { run() 오버라이딩 };
3. Thread의 자식클래스를 정의하여 작업 스레드 생성 in 실제 클래스 - 다른 클래스에서 만든 후 main()에서 객체선언 후 객체명.start();
4. Runnable 인터페이스 구현 후 사용 - 
class 구현클명 implements Runnable { //이 클래스는 작업 스레드가 아님. 그냥 Runnable을 구현한 클래스일뿐. 
  @Override
  public void run() {
    //스레드가 실행할 코드
  }} 
Runnable 객체명A =  new 구현클명(); //upcasting
Thread thread = new Thread(객체명A); //두줄의 코드를 통해 작업스레드로써 만들어줘야함.


스레드객체명.start(); - run() 함수 실행. - 메인스레드와 동시 실행됨. //Runnable의 run과 Thread의 run은 다른것임.
Thread.sleep(숫자); - 스레드의 쉬는시간을 설정.
예제 - multiThread - BeepPrintExample1,2,3
---------------------------------------------------------------------------------------------
스레드 이름 - 각 스레드는 이름을 가짐.
Thread 객체명 = new Thread();
객체명.setName("스레드 이름"); //setName으로 해당 스레드의 이름 설정

Thread 객체명 = Thread.currentThread(); //현재 실행중인 스레드를 얻는 static 함수
System.out.println(thread.getName()); // getName()으로 해당 스레드의 이름을 출력
---------------------------------------------------------------------------------------------
스레드 상태 - start()를 한다고 바로 시작하는 것이 아닌 실행 대기 상태("RUNNABLE")가 됨.
  -> CPU 스케쥴링에 따라 CPU를 점유하면 실행("RUNNING") 상태됨.
  -> run()의 모든 코드를 실행하기 전 다시 "RUNNABLE" 상태가 될 수 있음. -> 다른 스레드가 실행 상태로 변환.
  -> run()의 모든 코드 실행 시 종료 상태("TERMINATED")가 됨.
스객명.getState(); - 해당 스레드의 실행상태를 받아옴.

일시 정지로 보냄.
1. Thread.sleep(밀리세컨드 시간) - 지금 작업중인 스레드를 해당 시간동안 일시정지함.
2. 스객명B.join(); - main스레드에서 실행한다고 했을 때, main스레드를 정지 시키고, 스객명B의 run()코드를 전부 실행한 후 main스레드 실행.
3. wait()
일시 정지 상태에서 벗어남.
1. interrupt() : 실행 대기 or 종료 상태로 만듬.
2. notify(), notifyAll() : wait()으로 인해 일시 정지 상태인 스레드 -> 실행 대기 상태로 만듬.
실행 대기 상태로 보냄.
1. Thread.yield() : 다른 스레드에게 양보 후 대기상태에 있다가 CPU를 점유할 시 다시 실행됨
- wait() notify() notify()는 Ob
---------------------------------------------------------------------------------------------
스레드 동기화 - 멀티 스레드는 하나의 객체를 공유하여 작업도 가능 -> 예상치못한 결과를 야기할 수 있음.
               -> 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하기위해 "작업이 끝날 때까지" 객체에 잠금을 걸으면 됨.
               -> 이를 위해 자바는 "동기화 메소드와 동기화 블록" 제공.
1. [접근제한자] synchronized 리턴타입 메소드명() {} //한 스레드가 메소드를 다 사용하기 전까지 다른 스레드 접근 불가. //해당 메소드를 사용하는 동안 다른 스레드는 일시 정지 상태.
2. [접근제한자] 리턴타입 메소드명(){
  synchronized(공유객체){ //하나의 스레드만 실행하는 영역
  }
//여러 스레드가 실행하는 영역
}

wait([밀리세컨드 시간]) - 스레드를 일시 정지 상태로 만듬.
notify() - wait()에 의해 일시정지된 스레드 중 한개를 RUNNABLE 상태로 만듬.
notify() - wait()에 의해 일시정지된 모든 스레드를 RUNNABLE 상태로 만듬.
**이 3개의 메소드는 전부 synchronized메서드/블록 안에서만 사용가능!!** / 전부 final이라 재정의 불가능.
보통 notify()로 스레드를 대기 상태로 만들고, wait()으로 현재 진행중인 스레드를 일시 정지 상태로 만듬. -> 대기 상태 스레드 실행.
---------------------------------------------------------------------------------------------
스레드 안전 종료 - 스레드를 급하게 종료하기 위해 리소스를 정리하고 run()을 빨리 종료하는 것.
1. 조건이용 - while(stop)문을 사용하여 stop의 값을 main 스레드(다른 스레드)에서 원하는 바에 따라 stop값을 false로 바꿔주며 run()을 종료하는것.
2. interrupt() - 스레드가 일시 정지 상태에 있을 때, "InterruptedException 예외를 발생시키는 역할" 수행.
  sleep() / wait() / join() 사용 시 try-catch를 통해 예외처리를 해줘야하는데,
  main()스레드에서 스객명.start() 이후 스객명.interrup()을 통해, 3개 중 한개의 메소드를 사용하여 해당 메소드가 일시 정지 상태에 들어갔을 때 catch로 넘어가게 함.
---------------------------------------------------------------------------------------------
데몬 스레드 - 주 스레드의 작업을 돕는 보조 역할 스레드. 주 스레드 종료 시 같이 종료
             ex) 워드프로세서의 일정 시간마다 자동 저장, 유튜브의 영상 및 음악 재생.
스객명.setDemon(true); - 해당 스레드객체를 데몬 스레드로 변환
스객명.start();
---------------------------------------------------------------------------------------------
**스레드풀**************** - 작업 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 스레드가 하나씩 맡아 처리하는 방식.
java.util.concurrent 패키지에서 스레드풀 생성을 위한 "ExecutorService 인터페이스", "Executors 클래스" 제공.
  
Executors.newCatchedThread() - 0개에서 시작하여, 작업량 증가에 따라 int의 최대값만큼 스레드 수 증가, 60초 동안 스레드가 놀고 있다면 해당 스레드 제거.
Executors.newFixedThreadPool(최대 스레드 개수) - 0개에서 시작하여, 작업량 증가에 따라 최대 개수까지 스레드 수가 증가하지만, 놀고있는 스레드를 자동으로 제거하지 못함.
ExecutorService 객체명A = Executors.newCatchedThread();
ExecutorService 객체명A = Executors.newFixedThreadPool(최대 스레드 개수);

ExecutorService 객체명A = new ThreadPoolExecutors( //ThreadPoolExecutors의 부모 클래스가 ExecutorService를 구현하였기에 upcasting가능.
  코어스레드 개수, //초기에는 0개이고, 증가한 후 놀고있는 스레드를 제거할 때, 최소로 남겨놓는 수
  최대스레드 개수, 놀고있는 시간, 놀고있는 시간 단위, 작업 큐 - new synchronousQueue<Runnable>() );
---------------------------------------------------------------------------------------------
스레드풀 종료
객체명A.shutdown() - 현재 처리 중인 작업 + 작업 큐에 대기하는 모든 작업 처리 후 스레드풀 종료.
객체명A.shutdownNow() - 현재 작업 처리 중인 스레드를 interrupt하여 작업 중지 후 스레드풀 종료 -> 작업 큐에 있는 미처리 작업(Runnable)의 목록을 List<Runnable>에 담아 return.
---------------------------------------------------------------------------------------------
작업 생성과 처리 요청 - 하나의 작업은 "Runnable(리턴값 X)"이나 "Callable<T> (리턴타입 T)" 구현 클래스로 표현.
Callable 익명 객체 구현
new Callable<T> {
  @Override
  public T call() throws Exception {
    //작업 내용
    return T; }}








                                                                                     

  
