멀티스레드 : 하나의 프로세스에서 두가지 이상의 작업을 동시에 처리하는 것. / 하나의 스레드 문제 발생 -> 전체 스레드에 영향을 미침.
ex) 게임, 클라이언트-서버
스레드 : 코드의 실행 흐름.
---------------------------------------------------------------------------------------------
모든 자바 프로그램은 메인스레드가 main()메소드를 실행하면서 시작. -> main()메소드의 마지막코드 or return 만나면 실행 종료.
자바는 작업 스레드를 객체로 관리 - Thread 객체명 = Thread.currentThread(); System.out.println(currThread.getName());
멀티스레드에서는 실행중인 스레드가 존재 시 프로세스 종료 X.
---------------------------------------------------------------------------------------------
작업 스레드 생성 방법
1. Thread클래스로 작업 스레드 객체 직접 생성 - Thread 스레드객체명 = new Thread(Runnable 객체명); //Runnable upcasting
2. Thread의 자식클래스를 정의하여 작업 스레드 생성 in 익명객체 - Thread 스객명 = new Thread() { run() 오버라이딩 };
3. Thread의 자식클래스를 정의하여 작업 스레드 생성 in 실제 클래스 - 다른 클래스에서 만든 후 main()에서 객체선언 후 객체명.start();
4. Runnable 인터페이스 구현 후 사용 - 
class 구현클명 implements Runnable { //이 클래스는 작업 스레드가 아님. 그냥 Runnable을 구현한 클래스일뿐. 
  @Override
  public void run() {
    //스레드가 실행할 코드
  }} 
Runnable 객체명A =  new 구현클명(); //upcasting
Thread thread = new Thread(객체명A); //두줄의 코드를 통해 작업스레드로써 만들어줘야함.


스레드객체명.start(); - run() 함수 실행. - 메인스레드와 동시 실행됨. //Runnable의 run과 Thread의 run은 다른것임.
Thread.sleep(숫자); - 스레드의 쉬는시간을 설정.
예제 - multiThread - BeepPrintExample1,2,3
---------------------------------------------------------------------------------------------
스레드 이름 - 각 스레드는 이름을 가짐.
Thread 객체명 = new Thread();
객체명.setName("스레드 이름"); //setName으로 해당 스레드의 이름 설정

Thread 객체명 = Thread.currentThread(); //현재 실행중인 스레드를 얻는 static 함수
System.out.println(thread.getName()); // getName()으로 해당 스레드의 이름을 출력
---------------------------------------------------------------------------------------------
스레드 상태 - start()를 한다고 바로 시작하는 것이 아닌 실행 대기 상태("RUNNABLE")가 됨.
  -> CPU 스케쥴링에 따라 CPU를 점유하면 실행("RUNNING") 상태됨.
  -> run()의 모든 코드를 실행하기 전 다시 "RUNNABLE" 상태가 될 수 있음. -> 다른 스레드가 실행 상태로 변환.
  -> run()의 모든 코드 실행 시 종료 상태("TERMINATED")가 됨.
스객명.getState(); - 해당 스레드의 실행상태를 받아옴.

일시 정지로 보냄.
1. Thread.sleep(밀리세컨드 시간) - 지금 작업중인 스레드를 해당 시간동안 일시정지함.
2. 스객명B.join(); - main스레드에서 실행한다고 했을 때, main스레드를 정지 시키고, 스객명B의 run()코드를 전부 실행한 후 main스레드 실행.
3. wait()
일시 정지 상태에서 벗어남.
1. interrupt() : 실행 대기 or 종료 상태로 만듬.
2. notify(), notifyAll() : wait()으로 인해 일시 정지 상태인 스레드 -> 실행 대기 상태로 만듬.
실행 대기 상태로 보냄.
1. Thread.yield() : 다른 스레드에게 양보 후 대기상태에 있다가 CPU를 점유할 시 다시 실행됨
- wait() notify() notify()는 Ob
---------------------------------------------------------------------------------------------
스레드 동기화 - 멀티 스레드는 하나의 객체를 공유하여 작업도 가능 -> 예상치못한 결과를 야기할 수 있음.
               -> 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하기위해 "작업이 끝날 때까지" 객체에 잠금을 걸으면 됨.
               -> 이를 위해 자바는 "동기화 메소드와 동기화 블록" 제공.
1. [접근제한자] synchronized 리턴타입 메소드명() {} //한 스레드가 메소드를 다 사용하기 전까지 다른 스레드 접근 불가. //해당 메소드를 사용하는 동안 다른 스레드는 일시 정지 상태.
2. [접근제한자] 리턴타입 메소드명(){
  synchronized(공유객체){ //하나의 스레드만 실행하는 영역
  }
//여러 스레드가 실행하는 영역
}

wait() - 스레드를 일시 정지 상태로 만듬.
notify() - wait()에 의해 일시정지된 스레드 중 한개를 RUNNABLE 상태로 만듬.
notify() - wait()에 의해 일시정지된 모든 스레드를 RUNNABLE 상태로 만듬.
**이 3개의 메소드는 전부 synchronized메서드/블록 안에서만 사용가능!!**
보통 notify()로 스레드를 대기 상태로 만들고, wait()으로 현재 진행중인 스레드를 일시 정지 상태로 만듬. -> 대기 상태 스레드 실행.
  
